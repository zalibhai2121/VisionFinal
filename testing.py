import os
import tensorflow as tf
import pickle
import classify

# Remove any TF log outputs (e.g. CPU supporting stuff)
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Constants
X = pickle.load(open("A.pickle", "rb"))
Y = pickle.load(open("B.pickle", "rb"))
A = A/255

# Build the CNN
# Takes nothing as input, returns a model
def build_cnn():
    model = tf.keras.Sequential()
    # Convolutional Layer
    model.add(tf.keras.layers.Conv2D(64, (3,3), input_shape = A.shape[1:]))
    model.add(tf.keras.layers.Activation("relu"))
    # Pooling
    model.add(tf.keras.layers.MaxPool2D(pool_size=(2,2)))
    # MORE LAYERS
    model.add(tf.keras.layers.Conv2D(64, (3, 3)))
    model.add(tf.keras.layers.Activation("relu"))
    model.add(tf.keras.layers.MaxPool2D(pool_size=(2, 2)))
    # Flatten and Dense the layers
    model.add(tf.keras.layers.Flatten())
    model.add(tf.keras.layers.Dense(64))
    model.add(tf.keras.layers.Dense(1))
    model.add(tf.keras.layers.Activation("sigmoid"))
    # Compile the model
    model.compile(loss = "binary_crossentropy", # Maybe categorical_crossentropy?
                  optimizer = "adam",
                  metrix = ['accuracy'])

    print("Finished building the CNN")
    return model

# Fit the model to the images
# Takes nothing as input, returns a model
def fit_cnn():
    # Copy the model generated by build_cnn()
    model = build_cnn()
    # Fit the model
    model.fit(X, Y, batch_size = 32, validation_split = 0.1, )
    print("Shape of output", model.compute_output_shape(input_shape=(None, 64, 64, 1)))
    #Summarise the model
    model.summary()
    # Save a checkpoint
    checkpoint = tf.keras.callbacks.ModelCheckpoint("models/fingersteps/checkpoint_{epoch}")
    return model

# Trains the model
# Takes nothing as input, returns nothing as output
def train():

build_cnn()
